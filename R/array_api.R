# TileDB Storage Platform API
#
# TileDB Storage Platform REST API
#
# The version of the OpenAPI document: 2.2.19
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Array operations
#' @description tiledbcloud.Array
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ArrayActivityLog } \emph{  }
#' get array activity logs
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } start integer
#' \item \emph{ @param } end integer
#' \item \emph{ @param } event.types character
#' \item \emph{ @param } task.id character
#' \item \emph{ @param } has.task.id character
#' \item \emph{ @returnType } list( \link{ArrayActivityLog} ) \cr
#'
#'
#' \item status code : 200 | log of array activity
#'
#' \item return type : array[ArrayActivityLog] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysBrowserOwnedGet } \emph{  }
#' Fetch a list of all arrays that are owned directly by user or user&#39;s organizations
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } permissions character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } file.type list( character )
#' \item \emph{ @param } exclude.file.type list( character )
#' \item \emph{ @param } file.property list( character )
#' \item \emph{ @returnType } \link{ArrayBrowserData} \cr
#'
#'
#' \item status code : 200 | Array of array info that are owned directly by user or user&#39;s organizations
#'
#' \item return type : ArrayBrowserData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysBrowserOwnedSidebarGet } \emph{  }
#' Fetch a sidebar for arrays that are owned directly by user or user&#39;s organizations
#'
#' \itemize{
#' \item \emph{ @returnType } \link{ArrayBrowserSidebar} \cr
#'
#'
#' \item status code : 200 | Array of array info that are owned directly by user or user&#39;s organizations
#'
#' \item return type : ArrayBrowserSidebar 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysBrowserPublicGet } \emph{  }
#' Fetch a list of all arrays that have been shared publically
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } permissions character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } file.type list( character )
#' \item \emph{ @param } exclude.file.type list( character )
#' \item \emph{ @param } file.property list( character )
#' \item \emph{ @returnType } \link{ArrayBrowserData} \cr
#'
#'
#' \item status code : 200 | Array of array info that has been shared publically
#'
#' \item return type : ArrayBrowserData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysBrowserPublicSidebarGet } \emph{  }
#' Fetch a sidebar of all arrays that have been shared publically
#'
#' \itemize{
#' \item \emph{ @returnType } \link{ArrayBrowserSidebar} \cr
#'
#'
#' \item status code : 200 | Array of array info that has been shared publically
#'
#' \item return type : ArrayBrowserSidebar 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysBrowserSharedGet } \emph{  }
#' Fetch a list of all arrays that have been shared with the user
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } permissions character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } file.type list( character )
#' \item \emph{ @param } exclude.file.type list( character )
#' \item \emph{ @param } file.property list( character )
#' \item \emph{ @returnType } \link{ArrayBrowserData} \cr
#'
#'
#' \item status code : 200 | Array of array info that has been shared with the user
#'
#' \item return type : ArrayBrowserData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysBrowserSharedSidebarGet } \emph{  }
#' Fetch a list of all arrays that have been shared with the user
#'
#' \itemize{
#' \item \emph{ @returnType } \link{ArrayBrowserSidebar} \cr
#'
#'
#' \item status code : 200 | Array of array info that has been shared with the user
#'
#' \item return type : ArrayBrowserSidebar 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ArraysNamespaceArrayEndTimestampsGet } \emph{  }
#' retrieve a list of timestamps from the array fragment info listing in milliseconds, paginated
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @returnType } \link{ArrayEndTimestampData} \cr
#'
#'
#' \item status code : 200 | list of timestamps in milliseconds, paginated
#'
#' \item return type : ArrayEndTimestampData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ConsolidateArray } \emph{  }
#' consolidate an array at a specified URI
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } tiledb.config \link{TileDBConfig}
#'
#'
#' \item status code : 204 | array consolidated successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateArray } \emph{  }
#' create a array schema at a specified URI registered to a group/project
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } content.type character
#' \item \emph{ @param } array.schema \link{ArraySchema}
#' \item \emph{ @param } X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME character
#'
#'
#' \item status code : 204 | schema created successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteArray } \emph{  }
#' delete a array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } content.type character
#'
#'
#' \item status code : 204 | delete array successful
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeregisterArray } \emph{  }
#' deregister a array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#'
#'
#' \item status code : 204 | deregistered array successful
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetActivityLogById } \emph{  }
#' get activity log by ID
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ArrayActivityLog} \cr
#'
#'
#' \item status code : 200 | array activity
#'
#' \item return type : ArrayActivityLog 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetAllArrayMetadata } \emph{  }
#' get all array metadata user has access to
#'
#' \itemize{
#' \item \emph{ @param } public.share character
#' \item \emph{ @returnType } list( \link{ArrayInfo} ) \cr
#'
#'
#' \item status code : 200 | array metadata for all arrays user has access to
#'
#' \item return type : array[ArrayInfo] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArray } \emph{  }
#' get an ArraySchema using a url encoded uri
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } content.type character
#' \item \emph{ @returnType } \link{ArraySchema} \cr
#'
#'
#' \item status code : 200 | get ArraySchema
#'
#' \item return type : ArraySchema 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArrayMaxBufferSizes } \emph{  }
#' get the max buffer sizes of an array for a subarray
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } subarray character
#' \item \emph{ @param } content.type character
#' \item \emph{ @param } x.payer character
#' \item \emph{ @returnType } \link{MaxBufferSizes} \cr
#'
#'
#' \item status code : 200 | get the max buffer sizes of an array for a subarray
#'
#' \item return type : MaxBufferSizes 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArrayMetaDataJson } \emph{  }
#' get metadata from the array in JSON format
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } length integer
#' \item \emph{ @param } end.timestamp integer
#'
#'
#' \item status code : 200 | get array metadata
#'
#' \item return type : object 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArrayMetadata } \emph{  }
#' get metadata on an array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @returnType } \link{ArrayInfo} \cr
#'
#'
#' \item status code : 200 | array metadata for an array
#'
#' \item return type : ArrayInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArrayMetadataCapnp } \emph{  }
#' get metadata on an array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @returnType } \link{ArrayMetadata} \cr
#'
#'
#' \item status code : 200 | array metadata for an array
#'
#' \item return type : ArrayMetadata 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArrayNonEmptyDomain } \emph{  }
#' get the non empty domain of an array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } content.type character
#' \item \emph{ @param } x.payer character
#' \item \emph{ @returnType } \link{NonEmptyDomain} \cr
#'
#'
#' \item status code : 200 | get the non empty domain of an array
#'
#' \item return type : NonEmptyDomain 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArrayNonEmptyDomainJson } \emph{  }
#' get non-empty domain from the array in json format
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#'
#'
#' \item status code : 200 | get array non-empty domaim
#'
#' \item return type : object 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArraySampleData } \emph{  }
#' get an sample set of data from the array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } samples numeric
#' \item \emph{ @returnType } \link{ArraySample} \cr
#'
#'
#' \item status code : 200 | get array sample data
#'
#' \item return type : ArraySample 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArraySharingPolicies } \emph{  }
#' Get all sharing details of the array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @returnType } list( \link{ArraySharing} ) \cr
#'
#'
#' \item status code : 200 | List of all specific sharing policies
#'
#' \item return type : array[ArraySharing] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Array does not exist or user does not have permissions to view array-sharing policies
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetArraysInNamespace } \emph{  }
#' get metadata on all arrays in a namespace
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @returnType } list( \link{ArrayInfo} ) \cr
#'
#'
#' \item status code : 200 | array metadata for all arrays in a namespace
#'
#' \item return type : array[ArrayInfo] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetFragmentEndTimestamp } \emph{  }
#' Get fragment end_timestamp on an array, will search for the closest end_timestamp to the timestamp asked
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } end.timestamp integer
#'
#'
#' \item status code : 200 | fragment end_timestamp on an array
#'
#' \item return type : integer 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLastAccessedArrays } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @returnType } list( \link{LastAccessedArray} ) \cr
#'
#'
#' \item status code : 200 | gets last accessed arrays
#'
#' \item return type : array[LastAccessedArray] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RegisterArray } \emph{  }
#' register an array at a specified URI registered to the given namespace
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } array.metadata \link{ArrayInfoUpdate}
#'
#'
#' \item status code : 204 | schema registered successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ShareArray } \emph{  }
#' Share an array with a user
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } array.sharing \link{ArraySharing}
#'
#'
#' \item status code : 204 | Array shared successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Array does not exist or user does not have permissions to share array
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateArrayMetadata } \emph{  }
#' update metadata on an array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } array.metadata \link{ArrayInfoUpdate}
#'
#'
#' \item status code : 204 | array metadata updated successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateArrayMetadataCapnp } \emph{  }
#' update metadata on an array
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } array.metadata.entries \link{ArrayMetadata}
#'
#'
#' \item status code : 200 | array metadata updated successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ VacuumArray } \emph{  }
#' vacuum an array at a specified URI
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } tiledb.config \link{TileDBConfig}
#'
#'
#' \item status code : 204 | array vacuumed successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ArrayActivityLog  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.start <- 56 # integer | Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
#' var.end <- 56 # integer | End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
#' var.event.types <- 'event.types_example' # character | Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
#' var.task.id <- 'task.id_example' # character | Array task ID To filter activity to
#' var.has.task.id <- 'has.task.id_example' # character | Excludes activity log results that do not contain an array task UUID
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArrayActivityLog(var.namespace, var.array, start=var.start, end=var.end, event.types=var.event.types, task.id=var.task.id, has.task.id=var.has.task.id)
#'
#'
#' ####################  ArraysBrowserOwnedGet  ####################
#'
#' library(tiledbcloud)
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.namespace <- 'namespace_example' # character | namespace
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.permissions <- 'permissions_example' # character | permissions valid values include read, read_write, write, admin
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.file.type <- ['file.type_example'] # array[character] | file_type to search for, more than one can be included
#' var.exclude.file.type <- ['exclude.file.type_example'] # array[character] | file_type to exclude matching array in results, more than one can be included
#' var.file.property <- ['file.property_example'] # array[character] | file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysBrowserOwnedGet(page=var.page, per.page=var.per.page, search=var.search, namespace=var.namespace, orderby=var.orderby, permissions=var.permissions, tag=var.tag, exclude.tag=var.exclude.tag, file.type=var.file.type, exclude.file.type=var.exclude.file.type, file.property=var.file.property)
#'
#'
#' ####################  ArraysBrowserOwnedSidebarGet  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysBrowserOwnedSidebarGet()
#'
#'
#' ####################  ArraysBrowserPublicGet  ####################
#'
#' library(tiledbcloud)
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.namespace <- 'namespace_example' # character | namespace
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.permissions <- 'permissions_example' # character | permissions valid values include read, read_write, write, admin
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.file.type <- ['file.type_example'] # array[character] | file_type to search for, more than one can be included
#' var.exclude.file.type <- ['exclude.file.type_example'] # array[character] | file_type to exclude matching array in results, more than one can be included
#' var.file.property <- ['file.property_example'] # array[character] | file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysBrowserPublicGet(page=var.page, per.page=var.per.page, search=var.search, namespace=var.namespace, orderby=var.orderby, permissions=var.permissions, tag=var.tag, exclude.tag=var.exclude.tag, file.type=var.file.type, exclude.file.type=var.exclude.file.type, file.property=var.file.property)
#'
#'
#' ####################  ArraysBrowserPublicSidebarGet  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysBrowserPublicSidebarGet()
#'
#'
#' ####################  ArraysBrowserSharedGet  ####################
#'
#' library(tiledbcloud)
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.namespace <- 'namespace_example' # character | namespace
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.permissions <- 'permissions_example' # character | permissions valid values include read, read_write, write, admin
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.file.type <- ['file.type_example'] # array[character] | file_type to search for, more than one can be included
#' var.exclude.file.type <- ['exclude.file.type_example'] # array[character] | file_type to exclude matching array in results, more than one can be included
#' var.file.property <- ['file.property_example'] # array[character] | file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysBrowserSharedGet(page=var.page, per.page=var.per.page, search=var.search, namespace=var.namespace, orderby=var.orderby, permissions=var.permissions, tag=var.tag, exclude.tag=var.exclude.tag, file.type=var.file.type, exclude.file.type=var.exclude.file.type, file.property=var.file.property)
#'
#'
#' ####################  ArraysBrowserSharedSidebarGet  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysBrowserSharedSidebarGet()
#'
#'
#' ####################  ArraysNamespaceArrayEndTimestampsGet  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ArraysNamespaceArrayEndTimestampsGet(var.namespace, var.array, page=var.page, per.page=var.per.page)
#'
#'
#' ####################  ConsolidateArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.tiledb.config <- TileDBConfig$new() # TileDBConfig | tiledb configuration
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ConsolidateArray(var.namespace, var.array, var.tiledb.config)
#'
#'
#' ####################  CreateArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.content.type <- 'application/json' # character | Content Type of input and return mime
#' var.array.schema <- ArraySchema$new() # ArraySchema | ArraySchema being created
#' var.X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME <- 'X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME_example' # character | Optional registered access credentials to use for creation
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CreateArray(var.namespace, var.array, var.content.type, var.array.schema, X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME=var.X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME)
#'
#'
#' ####################  DeleteArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.content.type <- 'application/json' # character | Content Type of input and return mime
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteArray(var.namespace, var.array, var.content.type)
#'
#'
#' ####################  DeregisterArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeregisterArray(var.namespace, var.array)
#'
#'
#' ####################  GetActivityLogById  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.id <- 'id_example' # character | ID of the activity
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetActivityLogById(var.namespace, var.array, var.id)
#'
#'
#' ####################  GetAllArrayMetadata  ####################
#'
#' library(tiledbcloud)
#' var.public.share <- 'public.share_example' # character | Public share values can be one of exclude, only
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetAllArrayMetadata(public.share=var.public.share)
#'
#'
#' ####################  GetArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.content.type <- 'application/json' # character | Content Type of input and return mime
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArray(var.namespace, var.array, var.content.type)
#'
#'
#' ####################  GetArrayMaxBufferSizes  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.subarray <- 'subarray_example' # character | CSV string of subarray to get max buffer sizes for
#' var.content.type <- 'application/json' # character | Content Type of input and return mime
#' var.x.payer <- 'x.payer_example' # character | Name of organization or user who should be charged for this request
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArrayMaxBufferSizes(var.namespace, var.array, var.subarray, var.content.type, x.payer=var.x.payer)
#'
#'
#' ####################  GetArrayMetaDataJson  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.length <- 56 # integer | (optional) limit character length of returned values
#' var.end.timestamp <- 56 # integer | Milliseconds since Unix epoch, metadata will use open_at functionality to open array at the specific timestamp
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArrayMetaDataJson(var.namespace, var.array, length=var.length, end.timestamp=var.end.timestamp)
#'
#'
#' ####################  GetArrayMetadata  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArrayMetadata(var.namespace, var.array)
#'
#'
#' ####################  GetArrayMetadataCapnp  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArrayMetadataCapnp(var.namespace, var.array)
#'
#'
#' ####################  GetArrayNonEmptyDomain  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.content.type <- 'application/json' # character | Content Type of input and return mime
#' var.x.payer <- 'x.payer_example' # character | Name of organization or user who should be charged for this request
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArrayNonEmptyDomain(var.namespace, var.array, var.content.type, x.payer=var.x.payer)
#'
#'
#' ####################  GetArrayNonEmptyDomainJson  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArrayNonEmptyDomainJson(var.namespace, var.array)
#'
#'
#' ####################  GetArraySampleData  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.samples <- 5.0 # numeric | Number of sample results to return
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArraySampleData(var.namespace, var.array, samples=var.samples)
#'
#'
#' ####################  GetArraySharingPolicies  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArraySharingPolicies(var.namespace, var.array)
#'
#'
#' ####################  GetArraysInNamespace  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetArraysInNamespace(var.namespace)
#'
#'
#' ####################  GetFragmentEndTimestamp  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.end.timestamp <- 56 # integer | Milliseconds since Unix epoch
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetFragmentEndTimestamp(var.namespace, var.array, end.timestamp=var.end.timestamp)
#'
#'
#' ####################  GetLastAccessedArrays  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetLastAccessedArrays()
#'
#'
#' ####################  RegisterArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.array.metadata <- ArrayInfoUpdate$new() # ArrayInfoUpdate | metadata associated with array
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$RegisterArray(var.namespace, var.array, var.array.metadata)
#'
#'
#' ####################  ShareArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.array.sharing <- ArraySharing$new() # ArraySharing | Namespace and list of permissions to share with. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it's likely the array will not be shared with the namespace at all.
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ShareArray(var.namespace, var.array, var.array.sharing)
#'
#'
#' ####################  UpdateArrayMetadata  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.array.metadata <- ArrayInfoUpdate$new() # ArrayInfoUpdate | array metadata to update
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateArrayMetadata(var.namespace, var.array, var.array.metadata)
#'
#'
#' ####################  UpdateArrayMetadataCapnp  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.array.metadata.entries <- ArrayMetadata$new() # ArrayMetadata | List of metadata entries
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateArrayMetadataCapnp(var.namespace, var.array, var.array.metadata.entries)
#'
#'
#' ####################  VacuumArray  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.tiledb.config <- TileDBConfig$new() # TileDBConfig | tiledb configuration
#'
#' api.instance <- ArrayApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$VacuumArray(var.namespace, var.array, var.tiledb.config)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ArrayApi <- R6::R6Class(
  'ArrayApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ArrayActivityLog = function(namespace, array, start=NULL, end=NULL, event.types=NULL, task.id=NULL, has.task.id=NULL, ...){
      apiResponse <- self$ArrayActivityLogWithHttpInfo(namespace, array, start, end, event.types, task.id, has.task.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ArrayActivityLogWithHttpInfo = function(namespace, array, start=NULL, end=NULL, event.types=NULL, task.id=NULL, has.task.id=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      queryParams['start'] <- start

      queryParams['end'] <- end

      queryParams['event_types'] <- event.types

      queryParams['task_id'] <- task.id

      queryParams['has_task_id'] <- has.task.id

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/activity"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[ArrayActivityLog]", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ArraysBrowserOwnedGet = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, file.type=NULL, exclude.file.type=NULL, file.property=NULL, ...){
      apiResponse <- self$ArraysBrowserOwnedGetWithHttpInfo(page, per.page, search, namespace, orderby, permissions, tag, exclude.tag, file.type, exclude.file.type, file.property, ...)
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    ArraysBrowserOwnedGetWithHttpInfo = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, file.type=NULL, exclude.file.type=NULL, file.property=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['search'] <- search

      queryParams['namespace'] <- namespace

      queryParams['orderby'] <- orderby

      queryParams['permissions'] <- permissions

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['file_type'] <- file.type

      queryParams['exclude_file_type'] <- exclude.file.type

      queryParams['file_property'] <- file.property

      body <- NULL
      urlPath <- "/arrays/browser/owned"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    ArraysBrowserOwnedSidebarGet = function(...){
      apiResponse <- self$ArraysBrowserOwnedSidebarGetWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ArraysBrowserOwnedSidebarGetWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/arrays/browser/owned/sidebar"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArrayBrowserSidebar", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ArraysBrowserPublicGet = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, file.type=NULL, exclude.file.type=NULL, file.property=NULL, ...){
      apiResponse <- self$ArraysBrowserPublicGetWithHttpInfo(page, per.page, search, namespace, orderby, permissions, tag, exclude.tag, file.type, exclude.file.type, file.property, ...)
      resp <- apiResponse$response
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    ArraysBrowserPublicGetWithHttpInfo = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, file.type=NULL, exclude.file.type=NULL, file.property=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['search'] <- search

      queryParams['namespace'] <- namespace

      queryParams['orderby'] <- orderby

      queryParams['permissions'] <- permissions

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['file_type'] <- file.type

      queryParams['exclude_file_type'] <- exclude.file.type

      queryParams['file_property'] <- file.property

      body <- NULL
      urlPath <- "/arrays/browser/public"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    ArraysBrowserPublicSidebarGet = function(...){
      apiResponse <- self$ArraysBrowserPublicSidebarGetWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ArraysBrowserPublicSidebarGetWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/arrays/browser/public/sidebar"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArrayBrowserSidebar", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ArraysBrowserSharedGet = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, file.type=NULL, exclude.file.type=NULL, file.property=NULL, ...){
      apiResponse <- self$ArraysBrowserSharedGetWithHttpInfo(page, per.page, search, namespace, orderby, permissions, tag, exclude.tag, file.type, exclude.file.type, file.property, ...)
      resp <- apiResponse$response
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    ArraysBrowserSharedGetWithHttpInfo = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, file.type=NULL, exclude.file.type=NULL, file.property=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['search'] <- search

      queryParams['namespace'] <- namespace

      queryParams['orderby'] <- orderby

      queryParams['permissions'] <- permissions

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['file_type'] <- file.type

      queryParams['exclude_file_type'] <- exclude.file.type

      queryParams['file_property'] <- file.property

      body <- NULL
      urlPath <- "/arrays/browser/shared"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    ArraysBrowserSharedSidebarGet = function(...){
      apiResponse <- self$ArraysBrowserSharedSidebarGetWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ArraysBrowserSharedSidebarGetWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/arrays/browser/shared/sidebar"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArrayBrowserSidebar", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ArraysNamespaceArrayEndTimestampsGet = function(namespace, array, page=NULL, per.page=NULL, ...){
      apiResponse <- self$ArraysNamespaceArrayEndTimestampsGetWithHttpInfo(namespace, array, page, per.page, ...)
      resp <- apiResponse$response
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    ArraysNamespaceArrayEndTimestampsGetWithHttpInfo = function(namespace, array, page=NULL, per.page=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/end_timestamps"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    ConsolidateArray = function(namespace, array, tiledb.config, ...){
      apiResponse <- self$ConsolidateArrayWithHttpInfo(namespace, array, tiledb.config, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ConsolidateArrayWithHttpInfo = function(namespace, array, tiledb.config, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`tiledb.config`)) {
        stop("Missing required parameter `tiledb.config`.")
      }

      if (!missing(`tiledb.config`)) {
        body <- `tiledb.config`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/consolidate"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateArray = function(namespace, array, content.type, array.schema, X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME=NULL, ...){
      apiResponse <- self$CreateArrayWithHttpInfo(namespace, array, content.type, array.schema, X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateArrayWithHttpInfo = function(namespace, array, content.type, array.schema, X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`content.type`)) {
        stop("Missing required parameter `content.type`.")
      }

      if (missing(`array.schema`)) {
        stop("Missing required parameter `array.schema`.")
      }

      headerParams['Content-Type'] <- `content.type`

      headerParams['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] <- `X_TILEDB_CLOUD_ACCESS_CREDENTIALS_NAME`

      if (!missing(`array.schema`)) {
        body <- `array.schema`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteArray = function(namespace, array, content.type, ...){
      apiResponse <- self$DeleteArrayWithHttpInfo(namespace, array, content.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteArrayWithHttpInfo = function(namespace, array, content.type, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`content.type`)) {
        stop("Missing required parameter `content.type`.")
      }

      headerParams['Content-Type'] <- `content.type`

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeregisterArray = function(namespace, array, ...){
      apiResponse <- self$DeregisterArrayWithHttpInfo(namespace, array, ...)
      resp <- apiResponse$response
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    DeregisterArrayWithHttpInfo = function(namespace, array, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/deregister"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    GetActivityLogById = function(namespace, array, id, ...){
      apiResponse <- self$GetActivityLogByIdWithHttpInfo(namespace, array, id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetActivityLogByIdWithHttpInfo = function(namespace, array, id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/activity/{id}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArrayActivityLog", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetAllArrayMetadata = function(public.share=NULL, ...){
      apiResponse <- self$GetAllArrayMetadataWithHttpInfo(public.share, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetAllArrayMetadataWithHttpInfo = function(public.share=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['public_share'] <- public.share

      body <- NULL
      urlPath <- "/arrays"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[ArrayInfo]", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArray = function(namespace, array, content.type, ...){
      apiResponse <- self$GetArrayWithHttpInfo(namespace, array, content.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayWithHttpInfo = function(namespace, array, content.type, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`content.type`)) {
        stop("Missing required parameter `content.type`.")
      }

      headerParams['Content-Type'] <- `content.type`

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArraySchema", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArrayMaxBufferSizes = function(namespace, array, subarray, content.type, x.payer=NULL, ...){
      apiResponse <- self$GetArrayMaxBufferSizesWithHttpInfo(namespace, array, subarray, content.type, x.payer, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayMaxBufferSizesWithHttpInfo = function(namespace, array, subarray, content.type, x.payer=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`subarray`)) {
        stop("Missing required parameter `subarray`.")
      }

      if (missing(`content.type`)) {
        stop("Missing required parameter `content.type`.")
      }

      headerParams['Content-Type'] <- `content.type`

      headerParams['X-Payer'] <- `x.payer`

      queryParams['subarray'] <- subarray

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/max_buffer_sizes"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MaxBufferSizes", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArrayMetaDataJson = function(namespace, array, length=NULL, end.timestamp=NULL, ...){
      apiResponse <- self$GetArrayMetaDataJsonWithHttpInfo(namespace, array, length, end.timestamp, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayMetaDataJsonWithHttpInfo = function(namespace, array, length=NULL, end.timestamp=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      queryParams['length'] <- length

      queryParams['end_timestamp'] <- end.timestamp

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/metadata_json"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "object", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArrayMetadata = function(namespace, array, ...){
      apiResponse <- self$GetArrayMetadataWithHttpInfo(namespace, array, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayMetadataWithHttpInfo = function(namespace, array, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/metadata"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArrayInfo", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArrayMetadataCapnp = function(namespace, array, ...){
      apiResponse <- self$GetArrayMetadataCapnpWithHttpInfo(namespace, array, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayMetadataCapnpWithHttpInfo = function(namespace, array, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/array_metadata"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArrayMetadata", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArrayNonEmptyDomain = function(namespace, array, content.type, x.payer=NULL, ...){
      apiResponse <- self$GetArrayNonEmptyDomainWithHttpInfo(namespace, array, content.type, x.payer, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayNonEmptyDomainWithHttpInfo = function(namespace, array, content.type, x.payer=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`content.type`)) {
        stop("Missing required parameter `content.type`.")
      }

      headerParams['Content-Type'] <- `content.type`

      headerParams['X-Payer'] <- `x.payer`

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/non_empty_domain"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "NonEmptyDomain", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArrayNonEmptyDomainJson = function(namespace, array, ...){
      apiResponse <- self$GetArrayNonEmptyDomainJsonWithHttpInfo(namespace, array, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArrayNonEmptyDomainJsonWithHttpInfo = function(namespace, array, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/non_empty_domain_json"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "object", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArraySampleData = function(namespace, array, samples=5.0, ...){
      apiResponse <- self$GetArraySampleDataWithHttpInfo(namespace, array, samples, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArraySampleDataWithHttpInfo = function(namespace, array, samples=5.0, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      queryParams['samples'] <- samples

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/sample"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ArraySample", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArraySharingPolicies = function(namespace, array, ...){
      apiResponse <- self$GetArraySharingPoliciesWithHttpInfo(namespace, array, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetArraySharingPoliciesWithHttpInfo = function(namespace, array, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/share"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[ArraySharing]", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetArraysInNamespace = function(namespace, ...){
      apiResponse <- self$GetArraysInNamespaceWithHttpInfo(namespace, ...)
      resp <- apiResponse$response
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    GetArraysInNamespaceWithHttpInfo = function(namespace, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      body <- NULL
      urlPath <- "/arrays/{namespace}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    GetFragmentEndTimestamp = function(namespace, array, end.timestamp=NULL, ...){
      apiResponse <- self$GetFragmentEndTimestampWithHttpInfo(namespace, array, end.timestamp, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetFragmentEndTimestampWithHttpInfo = function(namespace, array, end.timestamp=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      queryParams['end_timestamp'] <- end.timestamp

      body <- NULL
      urlPath <- "/arrays/{namespace}/{array}/fragment_end_timestamp"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "integer", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLastAccessedArrays = function(...){
      apiResponse <- self$GetLastAccessedArraysWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLastAccessedArraysWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/arrays/last_accessed"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[LastAccessedArray]", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RegisterArray = function(namespace, array, array.metadata, ...){
      apiResponse <- self$RegisterArrayWithHttpInfo(namespace, array, array.metadata, ...)
      resp <- apiResponse$response
      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else {
        apiResponse
      }
    },

    RegisterArrayWithHttpInfo = function(namespace, array, array.metadata, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`array.metadata`)) {
        stop("Missing required parameter `array.metadata`.")
      }

      if (!missing(`array.metadata`)) {
        body <- `array.metadata`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/register"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      # MANUAL EDIT AFTER OPENAPI AUTOGEN
      .wrap_as_api_response(resp)
    },
    ShareArray = function(namespace, array, array.sharing, ...){
      apiResponse <- self$ShareArrayWithHttpInfo(namespace, array, array.sharing, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ShareArrayWithHttpInfo = function(namespace, array, array.sharing, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`array.sharing`)) {
        stop("Missing required parameter `array.sharing`.")
      }

      if (!missing(`array.sharing`)) {
        body <- `array.sharing`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/share"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateArrayMetadata = function(namespace, array, array.metadata, ...){
      apiResponse <- self$UpdateArrayMetadataWithHttpInfo(namespace, array, array.metadata, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateArrayMetadataWithHttpInfo = function(namespace, array, array.metadata, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`array.metadata`)) {
        stop("Missing required parameter `array.metadata`.")
      }

      if (!missing(`array.metadata`)) {
        body <- `array.metadata`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/metadata"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateArrayMetadataCapnp = function(namespace, array, array.metadata.entries, ...){
      apiResponse <- self$UpdateArrayMetadataCapnpWithHttpInfo(namespace, array, array.metadata.entries, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateArrayMetadataCapnpWithHttpInfo = function(namespace, array, array.metadata.entries, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`array.metadata.entries`)) {
        stop("Missing required parameter `array.metadata.entries`.")
      }

      if (!missing(`array.metadata.entries`)) {
        body <- `array.metadata.entries`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/array_metadata"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    VacuumArray = function(namespace, array, tiledb.config, ...){
      apiResponse <- self$VacuumArrayWithHttpInfo(namespace, array, tiledb.config, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    VacuumArrayWithHttpInfo = function(namespace, array, tiledb.config, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`tiledb.config`)) {
        stop("Missing required parameter `tiledb.config`.")
      }

      if (!missing(`tiledb.config`)) {
        body <- `tiledb.config`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/vacuum"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
