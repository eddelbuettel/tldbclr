# TileDB Storage Platform API
#
# TileDB Storage Platform REST API
#
# The version of the OpenAPI document: 2.2.19
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Groups operations
#' @description tiledbcloud.Groups
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ChangeGroupContents } \emph{  }
#' Changes the contents of the group by adding/removing members.
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @param } group.changes \link{GroupChanges}
#'
#'
#' \item status code : 204 | all changes applied successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateGroup } \emph{  }
#' Creates a new group in the namespace.
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } group.create \link{GroupCreate}
#'
#'
#' \item status code : 204 | group created successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DeleteGroup } \emph{  }
#' Deletes the group. The assets are not deleted nor are not relocated to any other group
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#'
#'
#' \item status code : 204 | group deleted successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetGroup } \emph{  }
#' Returns the the group
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @returnType } \link{GroupInfo} \cr
#'
#'
#' \item status code : 200 | the group metadata
#'
#' \item return type : GroupInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetGroupContents } \emph{  }
#' Returns the contents of the group
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } search character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } member.type list( character )
#' \item \emph{ @param } exclude.member.type list( character )
#' \item \emph{ @returnType } \link{GroupContents} \cr
#'
#'
#' \item status code : 200 | the group contents
#'
#' \item return type : GroupContents 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetGroupSharingPolicies } \emph{  }
#' Get all sharing details of the group
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @returnType } list( \link{GroupSharing} ) \cr
#'
#'
#' \item status code : 200 | List of all specific sharing policies
#'
#' \item return type : array[GroupSharing] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Group does not exist or user does not have permissions to view group-sharing policies
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GroupsBrowserOwnedFiltersGet } \emph{  }
#' Fetch data to initialize filters for the groups browser
#'
#' \itemize{
#' \item \emph{ @returnType } \link{GroupBrowserFilterData} \cr
#'
#'
#' \item status code : 200 | Filter data
#'
#' \item return type : GroupBrowserFilterData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GroupsBrowserPublicFiltersGet } \emph{  }
#' Fetch data to initialize filters for the groups browser
#'
#' \itemize{
#' \item \emph{ @returnType } \link{GroupBrowserFilterData} \cr
#'
#'
#' \item status code : 200 | Filter data
#'
#' \item return type : GroupBrowserFilterData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GroupsBrowserSharedFiltersGet } \emph{  }
#' Fetch data to initialize filters for the groups browser
#'
#' \itemize{
#' \item \emph{ @returnType } \link{GroupBrowserFilterData} \cr
#'
#'
#' \item status code : 200 | Filter data
#'
#' \item return type : GroupBrowserFilterData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GroupsGroupNamespaceGroupNameContentsFiltersGet } \emph{  }
#' Fetch data to initialize filters for the group contents
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @returnType } \link{GroupContentsFilterData} \cr
#'
#'
#' \item status code : 200 | Filter data
#'
#' \item return type : GroupContentsFilterData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ListOwnedGroups } \emph{  }
#' Returns one page of owned groups.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } permissions character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } flat character
#' \item \emph{ @param } parent character
#' \item \emph{ @returnType } \link{GroupBrowserData} \cr
#'
#'
#' \item status code : 200 | the group contents
#'
#' \item return type : GroupBrowserData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ListPublicGroups } \emph{  }
#' Returns one page of public groups.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } permissions character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } flat character
#' \item \emph{ @param } parent character
#' \item \emph{ @returnType } \link{GroupBrowserData} \cr
#'
#'
#' \item status code : 200 | the group contents
#'
#' \item return type : GroupBrowserData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ListSharedGroups } \emph{  }
#' Returns one page of shared groups.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search character
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } permissions character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @param } exclude.tag list( character )
#' \item \emph{ @param } flat character
#' \item \emph{ @param } parent character
#' \item \emph{ @param } shared.to list( character )
#' \item \emph{ @returnType } \link{GroupBrowserData} \cr
#'
#'
#' \item status code : 200 | the group contents
#'
#' \item return type : GroupBrowserData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RegisterGroup } \emph{  }
#' Registers an existing group in the namespace.
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } group.register \link{GroupRegister}
#'
#'
#' \item status code : 204 | group created successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ShareGroup } \emph{  }
#' Share a group with a namespace
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @param } group.sharing.request \link{GroupSharingRequest}
#'
#'
#' \item status code : 204 | Group shared successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Group does not exist or user does not have permissions to share group
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateGroup } \emph{  }
#' Changes attributes of the group
#'
#' \itemize{
#' \item \emph{ @param } group.namespace character
#' \item \emph{ @param } group.name character
#' \item \emph{ @param } group.update \link{GroupUpdate}
#'
#'
#' \item status code : 204 | attributes changed successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ChangeGroupContents  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#' var.group.changes <- GroupChanges$new() # GroupChanges | 
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ChangeGroupContents(var.group.namespace, var.group.name, group.changes=var.group.changes)
#'
#'
#' ####################  CreateGroup  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | The namespace of the group
#' var.group.create <- GroupCreate$new() # GroupCreate | 
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$CreateGroup(var.namespace, group.create=var.group.create)
#'
#'
#' ####################  DeleteGroup  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$DeleteGroup(var.group.namespace, var.group.name)
#'
#'
#' ####################  GetGroup  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetGroup(var.group.namespace, var.group.name)
#'
#'
#' ####################  GetGroupContents  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#' var.page <- 56 # integer | pagination offset for assets
#' var.per.page <- 56 # integer | pagination limit for assets
#' var.namespace <- 'namespace_example' # character | namespace to search for
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.member.type <- ['member.type_example'] # array[character] | member type to search for, more than one can be included
#' var.exclude.member.type <- ['exclude.member.type_example'] # array[character] | member type to exclude matching groups in results, more than one can be included
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetGroupContents(var.group.namespace, var.group.name, page=var.page, per.page=var.per.page, namespace=var.namespace, search=var.search, orderby=var.orderby, tag=var.tag, exclude.tag=var.exclude.tag, member.type=var.member.type, exclude.member.type=var.exclude.member.type)
#'
#'
#' ####################  GetGroupSharingPolicies  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetGroupSharingPolicies(var.group.namespace, var.group.name)
#'
#'
#' ####################  GroupsBrowserOwnedFiltersGet  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GroupsBrowserOwnedFiltersGet()
#'
#'
#' ####################  GroupsBrowserPublicFiltersGet  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GroupsBrowserPublicFiltersGet()
#'
#'
#' ####################  GroupsBrowserSharedFiltersGet  ####################
#'
#' library(tiledbcloud)
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GroupsBrowserSharedFiltersGet()
#'
#'
#' ####################  GroupsGroupNamespaceGroupNameContentsFiltersGet  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GroupsGroupNamespaceGroupNameContentsFiltersGet(var.group.namespace, var.group.name)
#'
#'
#' ####################  ListOwnedGroups  ####################
#'
#' library(tiledbcloud)
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.namespace <- 'namespace_example' # character | namespace
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.permissions <- 'permissions_example' # character | permissions valid values include read, read_write, write, admin
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.flat <- 'flat_example' # character | if true, ignores the nesting of groups and searches all of them
#' var.parent <- 'parent_example' # character | search only the children of the groups with this uuid
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ListOwnedGroups(page=var.page, per.page=var.per.page, search=var.search, namespace=var.namespace, orderby=var.orderby, permissions=var.permissions, tag=var.tag, exclude.tag=var.exclude.tag, flat=var.flat, parent=var.parent)
#'
#'
#' ####################  ListPublicGroups  ####################
#'
#' library(tiledbcloud)
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.namespace <- 'namespace_example' # character | namespace
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.permissions <- 'permissions_example' # character | permissions valid values include read, read_write, write, admin
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.flat <- 'flat_example' # character | if true, ignores the nesting of groups and searches all of them
#' var.parent <- 'parent_example' # character | search only the children of the groups with this uuid
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ListPublicGroups(page=var.page, per.page=var.per.page, search=var.search, namespace=var.namespace, orderby=var.orderby, permissions=var.permissions, tag=var.tag, exclude.tag=var.exclude.tag, flat=var.flat, parent=var.parent)
#'
#'
#' ####################  ListSharedGroups  ####################
#'
#' library(tiledbcloud)
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.namespace <- 'namespace_example' # character | namespace
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include last_accessed, size, name
#' var.permissions <- 'permissions_example' # character | permissions valid values include read, read_write, write, admin
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#' var.exclude.tag <- ['exclude.tag_example'] # array[character] | tags to exclude matching array in results, more than one can be included
#' var.flat <- 'flat_example' # character | if true, ignores the nesting of groups and searches all of them
#' var.parent <- 'parent_example' # character | search only the children of the groups with this uuid
#' var.shared.to <- ['shared.to_example'] # array[character] | namespaces to filter results of where there groups were shared to
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ListSharedGroups(page=var.page, per.page=var.per.page, search=var.search, namespace=var.namespace, orderby=var.orderby, permissions=var.permissions, tag=var.tag, exclude.tag=var.exclude.tag, flat=var.flat, parent=var.parent, shared.to=var.shared.to)
#'
#'
#' ####################  RegisterGroup  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | The namespace of the group
#' var.array <- 'array_example' # character | The unique name or id of the group
#' var.group.register <- GroupRegister$new() # GroupRegister | 
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$RegisterGroup(var.namespace, var.array, group.register=var.group.register)
#'
#'
#' ####################  ShareGroup  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#' var.group.sharing.request <- GroupSharingRequest$new() # GroupSharingRequest | Namespace and list of permissions to share with. Sharing is recursive, it is applied to all reachable subgroups and arrays of the group. An empty list of permissions will remove the namespace; if permissions already exist they will be deleted then new ones added. In the event of a failure, the new policies will be rolled back to prevent partial policies, and it's likely the group will not be shared with the namespace at all.
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ShareGroup(var.group.namespace, var.group.name, var.group.sharing.request)
#'
#'
#' ####################  UpdateGroup  ####################
#'
#' library(tiledbcloud)
#' var.group.namespace <- 'group.namespace_example' # character | The namespace of the group
#' var.group.name <- 'group.name_example' # character | The unique name or id of the group
#' var.group.update <- GroupUpdate$new() # GroupUpdate | 
#'
#' api.instance <- GroupsApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateGroup(var.group.namespace, var.group.name, group.update=var.group.update)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
GroupsApi <- R6::R6Class(
  'GroupsApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ChangeGroupContents = function(group.namespace, group.name, group.changes=NULL, ...){
      apiResponse <- self$ChangeGroupContentsWithHttpInfo(group.namespace, group.name, group.changes, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ChangeGroupContentsWithHttpInfo = function(group.namespace, group.name, group.changes=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      if (!missing(`group.changes`)) {
        body <- `group.changes`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/groups/{group_namespace}/{group_name}/contents"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateGroup = function(namespace, group.create=NULL, ...){
      apiResponse <- self$CreateGroupWithHttpInfo(namespace, group.create, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateGroupWithHttpInfo = function(namespace, group.create=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (!missing(`group.create`)) {
        body <- `group.create`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/groups/{namespace}/create"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DeleteGroup = function(group.namespace, group.name, ...){
      apiResponse <- self$DeleteGroupWithHttpInfo(group.namespace, group.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DeleteGroupWithHttpInfo = function(group.namespace, group.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      body <- NULL
      urlPath <- "/groups/{group_namespace}/{group_name}"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetGroup = function(group.namespace, group.name, ...){
      apiResponse <- self$GetGroupWithHttpInfo(group.namespace, group.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetGroupWithHttpInfo = function(group.namespace, group.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      body <- NULL
      urlPath <- "/groups/{group_namespace}/{group_name}"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupInfo", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetGroupContents = function(group.namespace, group.name, page=NULL, per.page=NULL, namespace=NULL, search=NULL, orderby=NULL, tag=NULL, exclude.tag=NULL, member.type=NULL, exclude.member.type=NULL, ...){
      apiResponse <- self$GetGroupContentsWithHttpInfo(group.namespace, group.name, page, per.page, namespace, search, orderby, tag, exclude.tag, member.type, exclude.member.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetGroupContentsWithHttpInfo = function(group.namespace, group.name, page=NULL, per.page=NULL, namespace=NULL, search=NULL, orderby=NULL, tag=NULL, exclude.tag=NULL, member.type=NULL, exclude.member.type=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['namespace'] <- namespace

      queryParams['search'] <- search

      queryParams['orderby'] <- orderby

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['member_type'] <- member.type

      queryParams['exclude_member_type'] <- exclude.member.type

      body <- NULL
      urlPath <- "/groups/{group_namespace}/{group_name}/contents"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupContents", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetGroupSharingPolicies = function(group.namespace, group.name, ...){
      apiResponse <- self$GetGroupSharingPoliciesWithHttpInfo(group.namespace, group.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetGroupSharingPoliciesWithHttpInfo = function(group.namespace, group.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      body <- NULL
      urlPath <- "/groups/{group_namespace}/{group_name}/share"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[GroupSharing]", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GroupsBrowserOwnedFiltersGet = function(...){
      apiResponse <- self$GroupsBrowserOwnedFiltersGetWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GroupsBrowserOwnedFiltersGetWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/groups/browser/owned/filters"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupBrowserFilterData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GroupsBrowserPublicFiltersGet = function(...){
      apiResponse <- self$GroupsBrowserPublicFiltersGetWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GroupsBrowserPublicFiltersGetWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/groups/browser/public/filters"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupBrowserFilterData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GroupsBrowserSharedFiltersGet = function(...){
      apiResponse <- self$GroupsBrowserSharedFiltersGetWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GroupsBrowserSharedFiltersGetWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/groups/browser/shared/filters"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupBrowserFilterData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GroupsGroupNamespaceGroupNameContentsFiltersGet = function(group.namespace, group.name, ...){
      apiResponse <- self$GroupsGroupNamespaceGroupNameContentsFiltersGetWithHttpInfo(group.namespace, group.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GroupsGroupNamespaceGroupNameContentsFiltersGetWithHttpInfo = function(group.namespace, group.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      body <- NULL
      urlPath <- "/groups/{group_namespace}/{group_name}/contents/filters"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupContentsFilterData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ListOwnedGroups = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, flat=NULL, parent=NULL, ...){
      apiResponse <- self$ListOwnedGroupsWithHttpInfo(page, per.page, search, namespace, orderby, permissions, tag, exclude.tag, flat, parent, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ListOwnedGroupsWithHttpInfo = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, flat=NULL, parent=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['search'] <- search

      queryParams['namespace'] <- namespace

      queryParams['orderby'] <- orderby

      queryParams['permissions'] <- permissions

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['flat'] <- flat

      queryParams['parent'] <- parent

      body <- NULL
      urlPath <- "/groups/browser/owned"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupBrowserData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ListPublicGroups = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, flat=NULL, parent=NULL, ...){
      apiResponse <- self$ListPublicGroupsWithHttpInfo(page, per.page, search, namespace, orderby, permissions, tag, exclude.tag, flat, parent, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ListPublicGroupsWithHttpInfo = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, flat=NULL, parent=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['search'] <- search

      queryParams['namespace'] <- namespace

      queryParams['orderby'] <- orderby

      queryParams['permissions'] <- permissions

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['flat'] <- flat

      queryParams['parent'] <- parent

      body <- NULL
      urlPath <- "/groups/browser/public"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupBrowserData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ListSharedGroups = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, flat=NULL, parent=NULL, shared.to=NULL, ...){
      apiResponse <- self$ListSharedGroupsWithHttpInfo(page, per.page, search, namespace, orderby, permissions, tag, exclude.tag, flat, parent, shared.to, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ListSharedGroupsWithHttpInfo = function(page=NULL, per.page=NULL, search=NULL, namespace=NULL, orderby=NULL, permissions=NULL, tag=NULL, exclude.tag=NULL, flat=NULL, parent=NULL, shared.to=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['search'] <- search

      queryParams['namespace'] <- namespace

      queryParams['orderby'] <- orderby

      queryParams['permissions'] <- permissions

      queryParams['tag'] <- tag

      queryParams['exclude_tag'] <- exclude.tag

      queryParams['flat'] <- flat

      queryParams['parent'] <- parent

      queryParams['shared_to'] <- shared.to

      body <- NULL
      urlPath <- "/groups/browser/shared"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "GroupBrowserData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RegisterGroup = function(namespace, array, group.register=NULL, ...){
      apiResponse <- self$RegisterGroupWithHttpInfo(namespace, array, group.register, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RegisterGroupWithHttpInfo = function(namespace, array, group.register=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (!missing(`group.register`)) {
        body <- `group.register`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/groups/{namespace}/{array}/register"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ShareGroup = function(group.namespace, group.name, group.sharing.request, ...){
      apiResponse <- self$ShareGroupWithHttpInfo(group.namespace, group.name, group.sharing.request, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ShareGroupWithHttpInfo = function(group.namespace, group.name, group.sharing.request, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      if (missing(`group.sharing.request`)) {
        stop("Missing required parameter `group.sharing.request`.")
      }

      if (!missing(`group.sharing.request`)) {
        body <- `group.sharing.request`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/groups/{group_namespace}/{group_name}/share"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateGroup = function(group.namespace, group.name, group.update=NULL, ...){
      apiResponse <- self$UpdateGroupWithHttpInfo(group.namespace, group.name, group.update, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateGroupWithHttpInfo = function(group.namespace, group.name, group.update=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`group.namespace`)) {
        stop("Missing required parameter `group.namespace`.")
      }

      if (missing(`group.name`)) {
        stop("Missing required parameter `group.name`.")
      }

      if (!missing(`group.update`)) {
        body <- `group.update`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/groups/{group_namespace}/{group_name}"
      if (!missing(`group.namespace`)) {
        urlPath <- gsub(paste0("\\{", "group_namespace", "\\}"), URLencode(as.character(`group.namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`group.name`)) {
        urlPath <- gsub(paste0("\\{", "group_name", "\\}"), URLencode(as.character(`group.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
