# TileDB Storage Platform API
#
# TileDB Storage Platform REST API
#
# The version of the OpenAPI document: 2.0.4
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Udf operations
#' @description tiledbcloud.Udf
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ GetUDFInfo } \emph{  }
#' get a specific UDF in the given namespace
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } name character
#' \item \emph{ @returnType } \link{UDFInfo} \cr
#'
#'
#' \item status code : 200 | UDFInfo was retrieved successfully
#'
#' \item return type : UDFInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | udf not found
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetUDFInfoList } \emph{  }
#' get a all UDFs accessible to the user
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } created.by character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } type character
#' \item \emph{ @param } search character
#' \item \emph{ @param } orderby character
#' \item \emph{ @param } tag list( character )
#' \item \emph{ @returnType } \link{UDFListingData} \cr
#'
#'
#' \item status code : 200 | UDFInfo list
#'
#' \item return type : UDFListingData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | udf not found
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetUDFInfoSharingPolicies } \emph{  }
#' Get all sharing details of the udf
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } name character
#' \item \emph{ @returnType } list( \link{UDFSharing} ) \cr
#'
#'
#' \item status code : 200 | List of all specific sharing policies
#'
#' \item return type : array[UDFSharing] 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | UDF does not exist or user does not have permissions to view array sharing policies
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RegisterUDFInfo } \emph{  }
#' register a UDF in the given namespace
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } name character
#' \item \emph{ @param } udf \link{UDFInfoUpdate}
#'
#'
#' \item status code : 204 | udf registered successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ShareUDFInfo } \emph{  }
#' Share a UDF with a user
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } name character
#' \item \emph{ @param } udf.sharing \link{UDFSharing}
#'
#'
#' \item status code : 204 | UDF shared successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | UDF does not exist or user does not have permissions to share udf
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SubmitGenericUDF } \emph{  }
#' submit a generic UDF in the given namespace
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } udf \link{GenericUDF}
#' \item \emph{ @param } accept.encoding character
#'
#'
#' \item status code : 200 | udf completed and the udf-type specific result is returned
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-TILEDB-CLOUD-TASK-ID \tab Task ID for just completed request \cr
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-TILEDB-CLOUD-TASK-ID \tab Task ID for just request if task was started \cr
#' }
#' }
#'
#' \strong{ SubmitUDF } \emph{  }
#' send a UDF to run against a specified array/URI registered to a group/project
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } array character
#' \item \emph{ @param } udf \link{UDF}
#' \item \emph{ @param } x.payer character
#' \item \emph{ @param } accept.encoding character
#'
#'
#' \item status code : 200 | udf completed and the udf-type specific result is returned
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-TILEDB-CLOUD-TASK-ID \tab Task ID for just completed request \cr
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-TILEDB-CLOUD-TASK-ID \tab Task ID for just request if task was started \cr
#' }
#' }
#'
#' \strong{ UpdateUDFInfo } \emph{  }
#' updated an existing registerd UDF in the given namespace
#'
#' \itemize{
#' \item \emph{ @param } namespace character
#' \item \emph{ @param } name character
#' \item \emph{ @param } udf \link{UDFInfoUpdate}
#'
#'
#' \item status code : 204 | udf updated successfully
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | error response
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  GetUDFInfo  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.name <- 'name_example' # character | name to register udf under
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetUDFInfo(var.namespace, var.name)
#'
#'
#' ####################  GetUDFInfoList  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace to filter
#' var.created.by <- 'created.by_example' # character | username to filter
#' var.page <- 56 # integer | pagination offset
#' var.per.page <- 56 # integer | pagination limit
#' var.type <- 'type_example' # character | udf type, \"generic\", \"single_array\"
#' var.search <- 'search_example' # character | search string that will look at name, namespace or description fields
#' var.orderby <- 'orderby_example' # character | sort by which field valid values include created_at, last_used, name
#' var.tag <- ['tag_example'] # array[character] | tag to search for, more than one can be included
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetUDFInfoList(namespace=var.namespace, created.by=var.created.by, page=var.page, per.page=var.per.page, type=var.type, search=var.search, orderby=var.orderby, tag=var.tag)
#'
#'
#' ####################  GetUDFInfoSharingPolicies  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.name <- 'name_example' # character | name of UDFInfo
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$GetUDFInfoSharingPolicies(var.namespace, var.name)
#'
#'
#' ####################  RegisterUDFInfo  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.name <- 'name_example' # character | name to register udf under
#' var.udf <- UDFInfoUpdate$new() # UDFInfoUpdate | udf to register
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$RegisterUDFInfo(var.namespace, var.name, var.udf)
#'
#'
#' ####################  ShareUDFInfo  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.name <- 'name_example' # character | name of UDFInfo
#' var.udf.sharing <- UDFSharing$new() # UDFSharing | Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$ShareUDFInfo(var.namespace, var.name, var.udf.sharing)
#'
#'
#' ####################  SubmitGenericUDF  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.udf <- GenericUDF$new() # GenericUDF | udf to run
#' var.accept.encoding <- 'accept.encoding_example' # character | Encoding to use
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$SubmitGenericUDF(var.namespace, var.udf, accept.encoding=var.accept.encoding)
#'
#'
#' ####################  SubmitUDF  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.array <- 'array_example' # character | name/uri of array that is url-encoded
#' var.udf <- UDF$new() # UDF | udf to run
#' var.x.payer <- 'x.payer_example' # character | Name of organization or user who should be charged for this request
#' var.accept.encoding <- 'accept.encoding_example' # character | Encoding to use
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$SubmitUDF(var.namespace, var.array, var.udf, x.payer=var.x.payer, accept.encoding=var.accept.encoding)
#'
#'
#' ####################  UpdateUDFInfo  ####################
#'
#' library(tiledbcloud)
#' var.namespace <- 'namespace_example' # character | namespace array is in (an organization name or user's username)
#' var.name <- 'name_example' # character | name to register udf under
#' var.udf <- UDFInfoUpdate$new() # UDFInfoUpdate | udf to update
#'
#' api.instance <- UdfApi$new()
#'
#' #Configure API key authorization: ApiKeyAuth
#' api.instance$apiClient$apiKeys['X-TILEDB-REST-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure HTTP basic authorization: BasicAuth
#' # provide your username in the user-serial format
#' api.instance$apiClient$username <- '<user-serial>'; 
#' # provide your api key generated using the developer portal
#' api.instance$apiClient$password <- '<api_key>';
#'
#' result <- api.instance$UpdateUDFInfo(var.namespace, var.name, var.udf)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
UdfApi <- R6::R6Class(
  'UdfApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    GetUDFInfo = function(namespace, name, ...){
      apiResponse <- self$GetUDFInfoWithHttpInfo(namespace, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetUDFInfoWithHttpInfo = function(namespace, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      urlPath <- "/udf/{namespace}/{name}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "UDFInfo", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetUDFInfoList = function(namespace=NULL, created.by=NULL, page=NULL, per.page=NULL, type=NULL, search=NULL, orderby=NULL, tag=NULL, ...){
      apiResponse <- self$GetUDFInfoListWithHttpInfo(namespace, created.by, page, per.page, type, search, orderby, tag, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetUDFInfoListWithHttpInfo = function(namespace=NULL, created.by=NULL, page=NULL, per.page=NULL, type=NULL, search=NULL, orderby=NULL, tag=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['namespace'] <- namespace

      queryParams['created_by'] <- created.by

      queryParams['page'] <- page

      queryParams['per_page'] <- per.page

      queryParams['type'] <- type

      queryParams['search'] <- search

      queryParams['orderby'] <- orderby

      queryParams['tag'] <- tag

      urlPath <- "/udfs"
      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "UDFListingData", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetUDFInfoSharingPolicies = function(namespace, name, ...){
      apiResponse <- self$GetUDFInfoSharingPoliciesWithHttpInfo(namespace, name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetUDFInfoSharingPoliciesWithHttpInfo = function(namespace, name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      urlPath <- "/udf/{namespace}/{name}/share"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[UDFSharing]", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RegisterUDFInfo = function(namespace, name, udf, ...){
      apiResponse <- self$RegisterUDFInfoWithHttpInfo(namespace, name, udf, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RegisterUDFInfoWithHttpInfo = function(namespace, name, udf, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`udf`)) {
        stop("Missing required parameter `udf`.")
      }

      if (!missing(`udf`)) {
        body <- `udf`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/udf/{namespace}/{name}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ShareUDFInfo = function(namespace, name, udf.sharing, ...){
      apiResponse <- self$ShareUDFInfoWithHttpInfo(namespace, name, udf.sharing, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ShareUDFInfoWithHttpInfo = function(namespace, name, udf.sharing, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`udf.sharing`)) {
        stop("Missing required parameter `udf.sharing`.")
      }

      if (!missing(`udf.sharing`)) {
        body <- `udf.sharing`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/udf/{namespace}/{name}/share"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SubmitGenericUDF = function(namespace, udf, accept.encoding=NULL, ...){
      apiResponse <- self$SubmitGenericUDFWithHttpInfo(namespace, udf, accept.encoding, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SubmitGenericUDFWithHttpInfo = function(namespace, udf, accept.encoding=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`udf`)) {
        stop("Missing required parameter `udf`.")
      }

      headerParams['Accept-Encoding'] <- `accept.encoding`

      if (!missing(`udf`)) {
        body <- `udf`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/udfs/generic/{namespace}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SubmitUDF = function(namespace, array, udf, x.payer=NULL, accept.encoding=NULL, ...){
      apiResponse <- self$SubmitUDFWithHttpInfo(namespace, array, udf, x.payer, accept.encoding, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SubmitUDFWithHttpInfo = function(namespace, array, udf, x.payer=NULL, accept.encoding=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`array`)) {
        stop("Missing required parameter `array`.")
      }

      if (missing(`udf`)) {
        stop("Missing required parameter `udf`.")
      }

      headerParams['X-Payer'] <- `x.payer`

      headerParams['Accept-Encoding'] <- `accept.encoding`

      if (!missing(`udf`)) {
        body <- `udf`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/arrays/{namespace}/{array}/udf/submit"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`array`)) {
        urlPath <- gsub(paste0("\\{", "array", "\\}"), URLencode(as.character(`array`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("tiledbcloud")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateUDFInfo = function(namespace, name, udf, ...){
      apiResponse <- self$UpdateUDFInfoWithHttpInfo(namespace, name, udf, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateUDFInfoWithHttpInfo = function(namespace, name, udf, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`namespace`)) {
        stop("Missing required parameter `namespace`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`udf`)) {
        stop("Missing required parameter `udf`.")
      }

      if (!missing(`udf`)) {
        body <- `udf`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/udf/{namespace}/{name}"
      if (!missing(`namespace`)) {
        urlPath <- gsub(paste0("\\{", "namespace", "\\}"), URLencode(as.character(`namespace`), reserved = TRUE), urlPath)
      }

      if (!missing(`name`)) {
        urlPath <- gsub(paste0("\\{", "name", "\\}"), URLencode(as.character(`name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-TILEDB-REST-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]) > 0) {
        headerParams['X-TILEDB-REST-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-TILEDB-REST-API-KEY"]), collapse='')
      }
      # HTTP basic auth
      headerParams['Authorization'] <- paste("Basic", base64enc::base64encode(charToRaw(paste(self$apiClient$username, self$apiClient$password, sep=":"))))

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
